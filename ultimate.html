<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>Shape Shifter 倒计时与烟花效果</title>
<style>
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: #000;
    overflow: hidden;
}
body.body--ready {
}
.canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 1;
}
#fireworks-canvas {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 2;
}
</style>
</head>
<body>
<canvas class="canvas"></canvas>
<canvas id="fireworks-canvas"></canvas>
<script>
var scenario = 0;
var scenarioStartTime = 0; 
var rotationAngle = 0; 

var S = {
  init: function () {
    S.Drawing.init('.canvas');
    document.body.classList.add('body--ready');
    S.UI.simulate('#countdown 3'); 
    S.Drawing.loop(function () {
      S.Shape.render();
    });
  }
};

S.Drawing = (function () {
  var canvas,
      context,
      renderFn,
      requestFrame = window.requestAnimationFrame       ||
                     window.webkitRequestAnimationFrame ||
                     window.mozRequestAnimationFrame    ||
                     window.oRequestAnimationFrame      ||
                     window.msRequestAnimationFrame     ||
                     function(callback) {
                       window.setTimeout(callback, 1000 / 60);
                     };
  return {
    init: function (el) {
      canvas = document.querySelector(el);
      context = canvas.getContext('2d');
      this.adjustCanvas();
      window.addEventListener('resize', function (e) {
        S.Drawing.adjustCanvas();
      });
    },
    loop: function (fn) {
      renderFn = !renderFn ? fn : renderFn;
      this.clearFrame();
      if (scenario === 4) {
        rotationAngle += 0.1;
      }
      renderFn();
      requestFrame.call(window, this.loop.bind(this));
    },
    adjustCanvas: function () {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    },
    clearFrame: function () {
      context.clearRect(0, 0, canvas.width, canvas.height);
    },
    getArea: function () {
      return { w: canvas.width, h: canvas.height };
    },
    drawCircle: function (p, c) {
      context.fillStyle = c.render();
      context.beginPath();
      context.arc(p.x, p.y, p.z, 0, 2 * Math.PI, true);
      context.closePath();
      context.fill();
    },
    getContext: function() {
      return context;
    }
  }
}());

S.UI = (function () {
  var sequence = [],
      cmd = '#',
      interval,
      time = null;
  function getValue(value) {
    return value && value.split(' ')[1];
  }
  function getAction(value) {
    value = value && value.split(' ')[0];
    return value && value[0] === cmd && value.substring(1);
  }
  function timedAction(fn, delay, max, reverse) {
    clearInterval(interval);
    var currentAction = reverse ? max : 1;
    fn(currentAction);
    if (!max || (!reverse && currentAction < max) || (reverse && currentAction > 0)) {
      interval = setInterval(function () {
        currentAction = reverse ? currentAction - 1 : currentAction + 1;
        fn(currentAction);
        if ((!reverse && max && currentAction === max) || (reverse && currentAction === 0)) {
          clearInterval(interval);
        }
      }, delay);
    }
  }
  function performAction(value) {
    var action, val, current;
    sequence = typeof(value) === 'object' ? value : sequence.concat(value.split('|'));
    timedAction(function (index) {
      current = sequence.shift();
      if (!current) return;
      action = getAction(current);
      val = getValue(current);
      if (action === 'countdown') {
        val = parseInt(val) || 3;
        val = val > 0 ? val : 3;
        scenario = 0;
        timedAction(function (idx) {
          if (idx === 0) {
            // --------------------- // SCENARIO 1
            startScenario1();
          } else {
            S.Shape.switchShape(S.ShapeBuilder.letter(idx), true);
          }
        }, 1000, val, true);
      } else {
        S.Shape.switchShape(S.ShapeBuilder.letter(current[0] === cmd ? 'What?' : current));
      }
    }, 1000, sequence.length);
  }
  return {
    simulate: function (action) {
      performAction(action);
    }
  }
}());

// --------------------- // SCENARIO 1
function startScenario1() {
  scenario = 1;
  scenarioStartTime = Date.now();
  S.Shape.switchShape(S.ShapeBuilder.circle(30));
  setTimeout(startScenario2, 2000);
}

// --------------------- // SCENARIO 2
function startScenario2() {
  scenario = 2;
  scenarioStartTime = Date.now();
  S.Shape.switchShape(S.ShapeBuilder.circle(5));
  setTimeout(startScenario3, 800);
}

// --------------------- // SCENARIO 3
function startScenario3() {
  scenario = 3;
  scenarioStartTime = Date.now();
  S.Shape.switchShape(S.ShapeBuilder.circle(60));
  setTimeout(startScenario4, 1500);
}

// --------------------- // SCENARIO 4
function startScenario4() {
  scenario = 4;
  scenarioStartTime = Date.now();
  setTimeout(startScenario5, 3000);
}

// --------------------- // SCENARIO 5
function startScenario5() {
  scenario = 5;
  scenarioStartTime = Date.now();
  S.Shape.switchShape(S.ShapeBuilder.letter('新年快乐!'));
  setTimeout(startScenario6, 8000);
}

S.Point = function (args) {
  // [PARAM]: x,y坐标位置, z为粒子半径大小, a为粒子不透明度, h为移动步骤计数, 影响粒子移动方式
  this.x = args.x;
  this.y = args.y;
  this.z = args.z;
  this.a = args.a;
  this.h = args.h;
};

S.Color = function (r, g, b, a) {
  // [PARAM]: r,g,b颜色通道值, a为透明度, 影响粒子颜色效果
  this.r = r;
  this.g = g;
  this.b = b;
  this.a = a;
};

S.Color.prototype = {
  render: function () {
    return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + this.a + ')';
  }
};

S.Dot = function (x, y) {
  // [PARAM]: 初始粒子位置x,y; p.z=5为初始粒子半径, p.a=1为初始不透明度
  this.p = new S.Point({
    x: x,
    y: y,
    z: 5,
    a: 1,
    h: 0
  });
  // [PARAM]: e为粒子移动速率系数, s为粒子静止状态标识
  this.e = 0.07;
  this.s = true;
  this.c = new S.Color(255, 255, 255, this.p.a);
  this.t = this.clone();
  this.q = [];
};

S.Dot.prototype = {
  clone: function () {
    return new S.Point({
      x: this.p.x,
      y: this.p.y,
      z: this.p.z,
      a: this.p.a,
      h: this.p.h
    });
  },
  _draw: function () {
    if (scenario >= 1 && scenario <= 5) {
      // [PARAM]: 随机赋值r,g,b实现粒子颜色动态变化效果
      var r = Math.floor(Math.random()*255);
      var g = Math.floor(Math.random()*255);
      var b = Math.floor(Math.random()*255);
      this.c = new S.Color(r,g,b,this.p.a);
    } else {
      this.c.a = this.p.a;
    }
    S.Drawing.drawCircle(this.p, this.c);
  },
  _moveTowards: function (n) {
    var details = this.distanceTo(n, true),
        dx = details[0],
        dy = details[1],
        d = details[2],
        e = this.e * d;
    if (this.p.h === -1) {
      this.p.x = n.x;
      this.p.y = n.y;
      return true;
    }
    if (d > 1) {
      this.p.x -= ((dx / d) * e);
      this.p.y -= ((dy / d) * e);
    } else {
      if (this.p.h > 0) {
        this.p.h--;
      } else {
        return true;
      }
    }
    return false;
  },
  _update: function () {
    if (this._moveTowards(this.t)) {
      var p = this.q.shift();
      if (p) {
        this.t.x = p.x || this.p.x;
        this.t.y = p.y || this.p.y;
        this.t.z = p.z || this.p.z;
        this.t.a = p.a || this.p.a;
        this.p.h = p.h || 0;
      } else {
        if (this.s) {
          this.p.x -= Math.sin(Math.random() * 3.142);
          this.p.y -= Math.sin(Math.random() * 3.142);
        } else {
          this.move(new S.Point({
            x: this.p.x + (Math.random() * 50) - 25,
            y: this.p.y + (Math.random() * 50) - 25,
          }));
        }
      }
    }
    let d = this.p.a - this.t.a;
    // [PARAM]: 通过差值d改变p.a,控制粒子透明度过渡效果
    this.p.a = Math.max(0.1, this.p.a - (d * 0.05));
    d = this.p.z - this.t.z;
    // [PARAM]: 通过差值d改变p.z,控制粒子大小过渡效果
    this.p.z = Math.max(1, this.p.z - (d * 0.05));
  },
  distanceTo: function (n, details) {
    var dx = this.p.x - n.x,
        dy = this.p.y - n.y,
        d = Math.sqrt(dx * dx + dy * dy);
    return details ? [dx, dy, d] : d;
  },
  move: function (p, avoidStatic) {
    if (!avoidStatic || (avoidStatic && this.distanceTo(p) > 1)) {
      this.q.push(p);
    }
  },
  render: function () {
    if (scenario === 4) {
      var a = S.Drawing.getArea();
      var cx = a.w/2;
      var cy = a.h/2;
      var dx = this.p.x - cx;
      var dy = this.p.y - cy;
      var cosA = Math.cos(rotationAngle);
      var sinA = Math.sin(rotationAngle);
      var rx = dx*cosA - dy*sinA;
      var ry = dx*sinA + dy*cosA;
      this.p.x = rx + cx;
      this.p.y = ry + cy;
    }
    this._update();
    this._draw();
  }
};

S.ShapeBuilder = (function () {
  var gap = 13,
      shapeCanvas = document.createElement('canvas'),
      shapeContext = shapeCanvas.getContext('2d'),
      fontSize = 500,
      fontFamily = 'Avenir, Helvetica Neue, Helvetica, Arial, sans-serif';
  function fit() {
    shapeCanvas.width = Math.floor(window.innerWidth / gap) * gap;
    shapeCanvas.height = Math.floor(window.innerHeight / gap) * gap;
    shapeContext.fillStyle = 'red';
    shapeContext.textBaseline = 'middle';
    shapeContext.textAlign = 'center';
  }
  function processCanvas() {
    var pixels = shapeContext.getImageData(0, 0, shapeCanvas.width, shapeCanvas.height).data;
    var dots = [],
        x = 0,
        y = 0,
        fx = shapeCanvas.width,
        fy = shapeCanvas.height,
        w = 0,
        h = 0;
    for (var p = 0; p < pixels.length; p += (4 * gap)) {
      if (pixels[p + 3] > 0) {
        dots.push(new S.Point({
          x: x,
          y: y
        }));
        w = x > w ? x : w;
        h = y > h ? y : h;
        fx = x < fx ? x : fx;
        fy = y < fy ? y : fy;
      }
      x += gap;
      if (x >= shapeCanvas.width) {
        x = 0;
        y += gap;
        p += gap * 4 * shapeCanvas.width;
      }
    }
    return { dots: dots, w: w + fx, h: h + fy };
  }
  function setFontSize(s) {
    shapeContext.font = 'bold ' + s + 'px ' + fontFamily;
  }
  function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function init() {
    fit();
    window.addEventListener('resize', fit);
  }
  init();
  return {
    circle: function (d) {
      var r = Math.max(0, d) / 2;
      shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
      shapeContext.beginPath();
      shapeContext.arc(r * gap, r * gap, r * gap, 0, 2 * Math.PI, false);
      shapeContext.fill();
      shapeContext.closePath();
      return processCanvas();
    },
    letter: function (l) {
      var s = 0;
      setFontSize(fontSize);
      s = Math.min(fontSize,
                  (shapeCanvas.width / shapeContext.measureText(l).width) * 0.8 * fontSize,
                  (shapeCanvas.height / fontSize) * (isNumber(l) ? 1 : 0.45) * fontSize);
      setFontSize(s);
      shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
      shapeContext.fillText(l, shapeCanvas.width / 2, shapeCanvas.height / 2);
      return processCanvas();
    },
    rectangle: function (w, h) {
      var dots = [],
          width = gap * w,
          height = gap * h;
      for (var y = 0; y < height; y += gap) {
        for (var x = 0; x < width; x += gap) {
          dots.push(new S.Point({
            x: x,
            y: y,
          }));
        }
      }
      return { dots: dots, w: width, h: height };
    }
  };
}());

S.Shape = (function () {
  var dots = [],
      width = 0,
      height = 0,
      cx = 0,
      cy = 0;
  function compensate() {
    var a = S.Drawing.getArea();
    cx = a.w / 2 - width / 2;
    cy = a.h / 2 - height / 2;
  }
  return {
    dots: dots, // Expose dots array
    shuffleIdle: function () {
      var a = S.Drawing.getArea();
      for (var d = 0; d < dots.length; d++) {
        if (!dots[d].s) {
          dots[d].move({
            x: Math.random() * a.w,
            y: Math.random() * a.h
          });
        }
      }
    },
    switchShape: function (n, fast) {
      var size,
          a = S.Drawing.getArea();
      width = n.w;
      height = n.h;
      compensate();
      if (n.dots.length > dots.length) {
        size = n.dots.length - dots.length;
        for (var d = 1; d <= size; d++) {
          // [PARAM]: 初始化更多粒子时p.z=5,a=1并随机给定位置
          dots.push(new S.Dot(a.w / 2, a.h / 2));
        }
      }
      var d = 0,
          i = 0;
      while (n.dots.length > 0) {
        i = Math.floor(Math.random() * n.dots.length);
        // [PARAM]: e为粒子速率, fast为快速移动时e增大,加快粒子位置变换
        dots[d].e = fast ? 0.25 : (dots[d].s ? 0.14 : 0.11);
        if (dots[d].s) {
          dots[d].move(new S.Point({
            z: Math.random() * 20 + 10,
            a: Math.random(),
            h: 18
          }));
        } else {
          dots[d].move(new S.Point({
            z: Math.random() * 5 + 5,
            h: 30
          }));
        }
        dots[d].s = true;
        dots[d].move(new S.Point({
          x: n.dots[i].x + cx,
          y: n.dots[i].y + cy,
          a: 1,
          z: 5,
          h: 0
        }));
        n.dots = n.dots.slice(0, i).concat(n.dots.slice(i + 1));
        d++;
      }
      for (var i = d; i < dots.length; i++) {
        if (dots[i].s) {
          dots[i].move(new S.Point({
            z: Math.random() * 20 + 10,
            a: Math.random(),
            h: 20
          }));
          dots[i].s = false;
          dots[i].e = 0.04;
          dots[i].move(new S.Point({
            x: Math.random() * a.w,
            y: Math.random() * a.h,
            a: 0.3,
            z: Math.random() * 4,
            h: 0
          }));
        }
      }
    },
    render: function () {
      for (var d = 0; d < dots.length; d++) {
        dots[d].render();
      }
    }
  }
}());

S.init();

// --------------------- // SCENARIO 6
function startScenario6() {
  scenario = 6;
  // 重写clearFrame实现拖影
  var origClearFrame = S.Drawing.clearFrame;
  S.Drawing.clearFrame = function() {
    var ctx = S.Drawing.getContext();
    var a = S.Drawing.getArea();
    ctx.fillStyle='rgba(0,0,0,0.1)';
    ctx.fillRect(0,0,a.w,a.h);
  };
  // 汇聚成爱心
  S.Shape.switchShape(S.ShapeBuilder.letter('❤'));
  setTimeout(function(){
    startScenario7();
  }, 3000); // 3秒后开始散开
}

// --------------------- // SCENARIO 7
function startScenario7() {
  scenario = 7;
  var a = S.Drawing.getArea();
  for (var d = 0; d < S.Shape.dots.length; d++) {
    var angle = Math.random() * 2 * Math.PI;
    var distance = Math.max(a.w, a.h) * 1.5;
    var targetX = a.w / 2 + Math.cos(angle) * distance;
    var targetY = a.h / 2 + Math.sin(angle) * distance;
    S.Shape.dots[d].move(new S.Point({
      x: targetX,
      y: targetY,
      z: 5,
      a: 1,
      h: 0
    }));
  }
  // After scattering, start fireworks
  setTimeout(startFireworks, 3000); // Adjust timing as needed
}

/** --------------------- // FIREWORKS SCENE --------------------- **/

function startFireworks() {
  (function() {
    /** 全局变量 **/
    let fireworksCanvas, fireworksCtx, cw, ch;
    let framesFW = 0;
    let seedsFW = [];
    let sparksFW = [];
    let gravityFW = 0.02;

    // 原基准数据
    let baseSeedLifeFW = 100; 
    let seedTimerFW = 0;

    // 较短的间隔产生更多烟花
    let seedIntervalFW = 5;

    /** 初始化画布 **/
    function initFireworks() {
        fireworksCanvas = document.getElementById("fireworks-canvas");
        fireworksCtx = fireworksCanvas.getContext("2d");
        resizeFireworksCanvas();
        window.addEventListener('resize', resizeFireworksCanvas);
        requestAnimationFrame(frameFireworks);
    }

    function resizeFireworksCanvas() {
        fireworksCanvas.width = window.innerWidth;
        fireworksCanvas.height = window.innerHeight;
        cw = fireworksCanvas.width;
        ch = fireworksCanvas.height;
    }

    /** 生成多颗种子粒子，增加随机性
     * 横轴从 cw*0.1 到 cw*0.9 范围内随机，避免贴边
     * vy在一个范围内随机（例如-3到-6）
     * 每颗种子有一个随机生命期，不再统一用seedLife固定值
     * 每次产生 2~5 颗随机数量的种子
     */
    function spawnSeedsFW() {
        let seedsPerSpawn = Math.floor(Math.random()*4+2); // 2~5颗
        for (let i=0; i<seedsPerSpawn; i++) {
            let startX = cw*0.1 + Math.random()*cw*0.8; // 横向范围更广
            let initialVy = -(3 + Math.random()*3); // -3 ~ -6
            let lifetime = Math.floor(baseSeedLifeFW + Math.random()*60 - 30); // 随机生命期
            if (lifetime < 50) lifetime = 50; // 保证最短生存时间
            
            let seed = {
                x: startX,
                y: ch - 50,
                vx: (Math.random()*0.6 - 0.3),
                vy: initialVy, 
                born: framesFW,
                lifetime: lifetime
            };
            seedsFW.push(seed);
        }
    }

    /** 爆炸生成火花 **/
    function splodeFW(x, y) {
        let count = 50 + Math.floor(Math.random()*50); // 火花数量也随机
        for (let i = 0; i < count; i++) {
            let angle = Math.random() * Math.PI * 2;
            let speed = 1 + Math.random()*2;
            let spark = {
                x: x,
                y: y,
                vx: Math.cos(angle)*speed,
                vy: Math.sin(angle)*speed,
                alpha: 1,
                radius: 2+Math.random()*3
            };
            sparksFW.push(spark);
        }
    }

    /** 更新逻辑 **/
    function doLogicFW() {
        if (seedTimerFW < framesFW) {
            seedTimerFW = framesFW + seedIntervalFW*Math.random()*10;
            // 每次产生多颗随机分布和参数的种子
            spawnSeedsFW();
        }

        // 更新种子
        for (let i=seedsFW.length-1; i>=0; i--) {
            let s = seedsFW[i];
            s.vy += gravityFW;
            s.x += s.vx;
            s.y += s.vy;
            if (framesFW - s.born > s.lifetime) {
                // 到达随机生命期后爆炸（间接导致不同高度的爆炸）
                splodeFW(s.x, s.y);
                seedsFW.splice(i,1);
            }
        }

        // 更新火花
        for (let i=sparksFW.length-1; i>=0; i--) {
            let sp = sparksFW[i];
            sp.vy += gravityFW*0.5;
            sp.x += sp.vx;
            sp.y += sp.vy;
            sp.alpha -= 0.01;
            if (sp.alpha <= 0) {
                sparksFW.splice(i,1);
            }
        }
    }

    /** 绘制 **/
    function drawFW() {
        fireworksCtx.clearRect(0,0,cw,ch);

        // 绘制种子
        fireworksCtx.fillStyle = "#fff";
        for (let s of seedsFW) {
            fireworksCtx.fillRect(s.x-2, s.y-2, 4,4);
        }

        // 绘制火花
        for (let sp of sparksFW) {
            fireworksCtx.globalAlpha = sp.alpha;
            // 随机颜色
            fireworksCtx.fillStyle = "hsl(" + Math.floor(Math.random()*360) + ",100%,50%)";
            fireworksCtx.beginPath();
            fireworksCtx.arc(sp.x, sp.y, sp.radius, 0, Math.PI*2);
            fireworksCtx.fill();
        }
        fireworksCtx.globalAlpha = 1;
    }

    /** 帧循环 **/
    function frameFireworks() {
        framesFW++;
        drawFW();
        doLogicFW();
        requestAnimationFrame(frameFireworks);
    }

    // 启动烟花
    initFireworks();
  })();
}
</script>
</body>
</html>
